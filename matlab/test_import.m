clc;
clear all;
close all;

dim = 0.07;
radius = dim/2.0;
%% Import data from text file.
% Script for importing data from the following text file:
%
%    /home/pnguyen/icub-workspace/skeleton3D/matlab/data/contactPts/data.log
%
% To extend the code to different selected data or a different text file,
% generate a function instead of a script.

% Auto-generated by MATLAB on 2017/07/05 14:48:00

%% Initialize variables. contactPts
filename = 'data/contactPts/data.log';
delimiter = ' ';

%% Format for each line of text:
%   column3: double (%f)
%	column4: double (%f)
%   column5: double (%f)
%	column6: double (%f)
%   column7: double (%f)
%	column8: double (%f)
% For more information, see the TEXTSCAN documentation.
formatSpec = '%*s%*s%f%f%f%f%f%f%[^\n\r]';

%% Open the text file.
fileID = fopen(filename,'r');

%% Read columns of data according to the format.
% This call is based on the structure of the file used to generate this
% code. If an error occurs for a different file, try regenerating the code
% from the Import Tool.
dataArray = textscan(fileID, formatSpec, 'Delimiter', delimiter, 'MultipleDelimsAsOne', true, 'EmptyValue' ,NaN, 'ReturnOnError', false);

%% Close the text file.
fclose(fileID);

%% Post processing for unimportable data.
% No unimportable data rules were applied during the import, so no post
% processing code is included. To generate code which works for
% unimportable data, select unimportable cells in a file and regenerate the
% script.

%% Allocate imported array to column variable names
VarName3 = dataArray{:, 1};
VarName4 = dataArray{:, 2};
VarName5 = dataArray{:, 3};
VarName6 = dataArray{:, 4};
VarName7 = dataArray{:, 5};
VarName8 = dataArray{:, 6};

contactPts = [VarName3, VarName4, VarName5];

%% Clear temporary variables
clearvars filename delimiter formatSpec fileID ans;

%% Initialize variables.
filename = 'data/touchPartPose/data.log';
delimiter = ' ';

%% Format for each line of text:
%   column3: double (%f)
%	column4: double (%f)
%   column5: double (%f)
% For more information, see the TEXTSCAN documentation.
formatSpec = '%*s%*s%f%f%f%f%f%f%[^\n\r]';

%% Open the text file.
fileID = fopen(filename,'r');

%% Read columns of data according to the format.
dataArray = textscan(fileID, formatSpec, 'Delimiter', delimiter, 'MultipleDelimsAsOne', true, 'EmptyValue' ,NaN, 'ReturnOnError', false);

%% Close the text file.
fclose(fileID);

%% Post processing for unimportable data.
% No unimportable data rules were applied during the import, so no post
% processing code is included. To generate code which works for
% unimportable data, select unimportable cells in a file and regenerate the
% script.

%% Allocate imported array to column variable names
VarName3 = dataArray{:, 1};
VarName4 = dataArray{:, 2};
VarName5 = dataArray{:, 3};
VarName6 = dataArray{:, 4};
VarName7 = dataArray{:, 5};
VarName8 = dataArray{:, 6};

touchPartPose = [VarName3, VarName4, VarName5];
elbowPose = [VarName6, VarName7, VarName8];

%% Clear temporary variables
clearvars filename delimiter formatSpec fileID ans;

%% Remove invalid samples, which has big distance (>0.25)
v= contactPts - touchPartPose;
dist = sqrt(sum(abs(v).^2,2));
idx_out = find(dist>0.15);

touchPartPose(idx_out(1),:)

v(idx_out,:) = [];
dist(idx_out, : ) = []; 
touchPartPose(idx_out,:) = [];
elbowPose(idx_out,:) = [];
contactPts(idx_out,:) = [];

touchPartPose(idx_out(1),:);

touchPts = touchPartPose + v*radius./dist;

%% Move the touchPartPose closer to contactPts by the bounding radius
inMatrix = [touchPts, elbowPose];
csvwrite('inMatrix.csv',inMatrix)
csvwrite('refMatrix.csv',contactPts)

%% Make dataset more balance in term of number of samples
rng default
k = 10;
[idCluster, C] = kmeans(contactPts,k);

% figure;
minSz = length(contactPts);
for id=1:k
    szCluster = length(find(idCluster==id));
    fprintf('cluster %2d:\t %4d samples,\t has centroid at [%s] \n',id,szCluster,num2str(C(id,:),4))
%     contactPts_clustered[;:] = contactPts(idx==1,:);
    if (szCluster < minSz)
        minSz = szCluster;
    end
end
minSz
inMatrix_balanced = [];
refMatrix_balanced = [];

for id = 1:k
    contactPts_clustered = contactPts(idCluster==id,:);
    [y_sampled, id_sample] = datasample(contactPts_clustered,minSz);
    inMatrix_clustered = inMatrix(idCluster==id,:);
    x_sampled = inMatrix_clustered(id_sample,:);
    
    refMatrix_balanced = [refMatrix_balanced;y_sampled];
    inMatrix_balanced = [inMatrix_balanced;x_sampled];
    
end
    
csvwrite('inMatrix_balanced.csv',inMatrix_balanced)
csvwrite('refMatrix_balanced.csv',refMatrix_balanced)
% 
% [idCluster_, C_] = kmeans(refMatrix_balanced,k);
% 
% minSz = length(refMatrix_balanced);
% for id=1:k
%     szCluster = length(find(idCluster_==id));
%     fprintf('cluster %2d:\t %4d samples,\t has centroid at [%s] \n',id,szCluster,num2str(C_(id,:),4))
% %     contactPts_clustered[;:] = contactPts(idx==1,:);
%     if (szCluster < minSz)
%         minSz = szCluster;
%     end
% end

%% Cluster the contact points

% [idx0,idx1] = cluster_3d_points(contactPts, 0.15);
% contactPts0 = contactPts(idx0,:);   touchPartPose0 = touchPartPose(idx0,:);
% contactPts1 = contactPts(idx1,:);   touchPartPose1 = touchPartPose(idx1,:);

% [idx1,idx2] = cluster_3d_points(contactPts1, 0.01);
% contactPts1 = contactPts(idx1,:);   touchPartPose1 = touchPartPose(idx1,:);
% contactPts2 = contactPts(idx2,:);   touchPartPose2 = touchPartPose(idx2,:);
% 
% [idx2,idx3] = cluster_3d_points(contactPts2, 0.005);
% contactPts2 = contactPts(idx2,:);   touchPartPose2 = touchPartPose(idx2,:);
% contactPts3 = contactPts(idx3,:);   touchPartPose3 = touchPartPose(idx3,:);


%% Plot
figure;

plot3(contactPts(:,1),contactPts(:,2),contactPts(:,3),'rx',...
    touchPartPose(:,1),touchPartPose(:,2),touchPartPose(:,3),'go',...
    touchPts(:,1),touchPts(:,2),touchPts(:,3),'b*',...
    elbowPose(:,1),elbowPose(:,2),elbowPose(:,3),'g+');
xlabel('x (m)'); ylabel('y (m)'); zlabel('z (m)'); 
xlim([-0.7 0.0]); ylim([-0.3 0.3]); zlim([-0.2 0.4])
title('Contact points in 3D')
grid on;

%% Plot
figure;

plot3(contactPts(:,1),contactPts(:,2),contactPts(:,3),'rx',...
    touchPts(:,1),touchPts(:,2),touchPts(:,3),'b*');
legend('contactPts','touchPts');
xlabel('x (m)'); ylabel('y (m)'); zlabel('z (m)'); 
xlim([-0.7 0.0]); ylim([-0.3 0.3]); zlim([-0.2 0.4])
title('Contact points in 3D')
grid on;

%% Plot
% figure;
% 
% plot3(contactPts0(:,1),contactPts0(:,2),contactPts0(:,3),'rx',touchPartPose0(:,1),touchPartPose0(:,2),touchPartPose0(:,3),'go');
% xlabel('x (m)'); ylabel('y (m)'); zlabel('z (m)'); 
% xlim([-0.4 0.0]); ylim([-0.3 0.3]); zlim([-0.2 0.4])
% title('Contact points in 3D')
% grid on;

%% Plot
% figure;
% 
% plot3(contactPts1(:,1),contactPts1(:,2),contactPts1(:,3),'rx',touchPartPose1(:,1),touchPartPose1(:,2),touchPartPose1(:,3),'go');
% xlabel('x (m)'); ylabel('y (m)'); zlabel('z (m)'); 
% xlim([-0.4 0.0]); ylim([-0.3 0.3]); zlim([-0.2 0.4])
% title('Contact points in 3D')
% grid on;

% %% Plot
% figure;
% 
% plot3(contactPts2(:,1),contactPts2(:,2),contactPts2(:,3),'rx',touchPartPose2(:,1),touchPartPose2(:,2),touchPartPose2(:,3),'go');
% xlabel('x (m)'); ylabel('y (m)'); zlabel('z (m)'); 
% xlim([-0.4 0.0]); ylim([-0.3 0.3]); zlim([-0.2 0.4])
% title('Contact points in 3D')
% grid on;
% 
% %% Plot
% figure;
% 
% plot3(contactPts3(:,1),contactPts3(:,2),contactPts3(:,3),'rx',touchPartPose3(:,1),touchPartPose3(:,2),touchPartPose3(:,3),'go');
% xlabel('x (m)'); ylabel('y (m)'); zlabel('z (m)'); 
% xlim([-0.4 0.0]); ylim([-0.3 0.3]); zlim([-0.2 0.4])
% title('Contact points in 3D')
% grid on;

%%
% fun = @(x)100*(x(2)-x(1)^2)^2 + (1-x(1))^2;